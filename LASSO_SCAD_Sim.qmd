---
title: "MATH 686 Project"
author: "Daniel Krasnov"
bibliography: bib.bib
execute: 
  cache: true
format: pdf
editor: visual
---

# Introduction

First, the SCAD and LASSO methods are introduced for variable selection in the Cox's Proportional Hazards Model. Then results from [@fan2002variable] are replicated which compares these variable selection methods with AIC and BIC best subset selection. Finally a dataset is introduced to which SCAD and LASSO will be applied for my MATH 686 project.

# Background

INTODUCE Survival analysis and data

INTRODUCE COX'S MODEL HERE

The following is taken from [@fan2002variable]. Consider independent samples $(\mathbf{x}_i,Y_i)$ with conditional density $f_i(y_i;\mathbf{X}^T_i,\mathbf{\beta})$. Let $\ell_i=\text{log}f_i$. Then a general form of penalized likelihood is given by

$$
\sum^n_{i=1}\ell_i{y_i;\mathbf{x}_i^T\mathbf{\beta}}-n\sum^d_{j=1}p_\lambda(|\beta_j|)
$$ where $d$ is the dimension of $\mathbf{\beta}$, $p_\lambda(.)$ is some penalty function and $|lambda$ is a tuning parameter. Selecting a function $p_\lambda(.)$ amounts to selecting a variable selection method for COx's Proportional Hazards model. In this study we will consider two penalties: LASSO and SCAD,

\begin{align*}
p_\lambda(|\theta|)&=\lambda|\theta| & \text{LASSO} \\
p_\lambda(\theta) &= I(\theta\leq\lambda) + \frac{(a\lambda-\theta)_+}{(a-1)\lambda}I(\theta>\lambda) & \text{SCAD}
\end{align*}

where $a > 2$ and $\theta > 0$. In general, a value of $a=3.7$ is used and we adopt this for our study.

# SCAD and LASSO Simulation

In this section model performance is compared on simulated data for the LASSO, SCAD, and AIC and BIC best subset regression parameter selection techniques. Model performance is assessed through the Relative Model Errors (RME)

$$
\mathbb{E}\left\{\text{exp}(-\mathbf{X}^T\hat{\beta})-\text{exp}(-\mathbf{X}^T\beta_0)\right\}^2.
$$

We simulate $100$ datasets with $n=75$ and $n=100$ observations from the exponential hazard model

$$
h(t|\mathbf{x}) = \text{exp}(\mathbf{x}^T\mathbf{\beta})
$$

-   $\beta = (0.8, 0, 0, 1, 0, 0, 0.6, 0)^T$,
-   $x_i$ are marginally standard normal with correlation $\rho=0.5$,
-   Censoring times are exponentially distributed with mean $U\text{exp}(\mathbf{x^T\beta_0})$, $U\sim \text{Uniform}(1,3)$.

Our simulations yielded the following results:

```{r, warning=FALSE, message=FALSE,echo=FALSE}
library(MASS)
library(survival)
library(glmnet)
library(ncvreg)
library(ggplot2)
library(dplyr)
library(knitr)
library(gtools)
```

```{r, warning=FALSE, message=FALSE,echo=FALSE}
lasso_scad_cox_sim = function(N,n){   # N:simulation times; n:data pts
  Beta = c(0.8,0,0,1,0,0,0.6,0)
  p = length(Beta) # number of coeff
  corr = matrix(NA,p,p)
  x = matrix(NA,n,p)

  ME_part = rep(NA,N) # To store model error
  ME_LASSO = rep(NA,N)
  Beta_part_all = matrix(NA,N,p)
  Beta_LASSO_all = matrix(NA,N,p)

  # ME_part_2 = rep(NA,N) # To store model error
  ME_SCAD = rep(NA,N)
  # Beta_part_all_2 = matrix(NA,N,p)
  Beta_SCAD_all = matrix(NA,N,p)


  t = 1
  while(t <= N){
    # print(t)
    # Step1: Set up correlation matrix
    for(i in 1:p){
      for(j in 1:p){
        corr[i,j] = (0.5)^(abs(i-j))
      }
    }

    # Step2: Simulate n data pts
    x = mvrnorm(n, rep(0,p), Sigma = corr)
    x = scale(x) #scale to make sure coeff are in same unit

    # Step3: Generate time "y" using h(t)
    y = rexp(n,rate=exp(x %*% Beta))

    # Step4: Generating censoring time "cen" using mean U*h(t)
    U = runif(n, min = 1, max = 3) # U is uniformly distributed on [1,3]
    cen = U

    # Step5: Add status based on censoring time "cen" and actual survival time "y"
    status = as.numeric(y <= cen) # 1 if death, 0 if censored

    # Step6: Fit by Cox's PH model with LASSO
    time = pmin(y,cen) # time until death or censoring
    fit_LASSO = cv.glmnet(x, Surv(time,status), family = "cox",alpha=1) 
    fit_SCAD <-  cv.ncvsurv(x, Surv(time,status), penalty = "SCAD",gamma=3.7)

    Beta_LASSO = as.vector(coef(fit_LASSO, s = fit_LASSO$lambda.min))
    Beta_SCAD <- as.vector(coef(fit_SCAD, s = fit_SCAD$lambda.min))

    Beta_LASSO_all[t,] =  Beta_LASSO # Store the estimated beta simulated this time
    Beta_SCAD_all[t,] <- Beta_SCAD

    # Step7: Fit by Cox's PH model with partial likelihood by default
    # so that we can compute MRME later
    fit_part = coxph(Surv(time,status)~x)
    Beta_part = as.numeric(coef(fit_part))
    Beta_part_all[t,] = Beta_part

    # Step8: Compute Model Error
    # ME_part[t] =  t(exp(x%*%Beta_part_all[t,])-exp(x%*%Beta))%*%(exp(x%*%Beta_part_all[t,])-exp(x%*%Beta))
    # ME_LASSO[t] = t(exp(x%*%Beta_LASSO_all[t,])-exp(x%*%Beta))%*%(exp(x%*%Beta_LASSO_all[t,])-exp(x%*%Beta))
    # ME_SCAD[t] = t(exp(x%*%Beta_SCAD_all[t,])-exp(x%*%Beta))%*%(exp(x%*%Beta_SCAD_all[t,])-exp(x%*%Beta))

    ME_part[t] =  mean((exp(-x%*%Beta_part_all[t,])-exp(-x%*%Beta))^2)
    ME_LASSO[t] = mean((exp(-x%*%Beta_LASSO_all[t,])-exp(-x%*%Beta))^2)
    ME_SCAD[t] = mean((exp(-x%*%Beta_SCAD_all[t,])-exp(-x%*%Beta))^2)

    t = t+1
  }

  # Take mean, std of each coeff
  Beta_part_mean = colMeans(Beta_part_all)
  Beta_LASSO_mean = colMeans(Beta_LASSO_all)
  Beta_SCAD_mean <- colMeans(Beta_SCAD_all)

  Beta_part_std = apply(Beta_part_all,2,sd)
  Beta_LASSO_std = apply(Beta_LASSO_all,2,sd)
  Beta_SCAD_std = apply(Beta_SCAD_all,2,sd)

  # Count avg correct and incorrect zero coeff of LASSO model
  avg_correct_LASSO = mean(rowSums(abs(Beta_LASSO_all[,c(2,3,5,6,8)])<0.01))
  avg_correct_SCAD = mean(rowSums(abs(Beta_SCAD_all[,c(2,3,5,6,8)])<0.01))

  avg_incorrect_LASSO = mean(rowSums(abs(Beta_LASSO_all[,c(1,4,7)])<0.01))
  avg_incorrect_SCAD = mean(rowSums(abs(Beta_SCAD_all[,c(1,4,7)])<0.01))


  # Generate Table
  list(
    Initial_Beta = Beta,
    Estimate_Beta_LASSO = Beta_LASSO_mean,
    Estimate_Beta_SCAD = Beta_SCAD_mean,
    Simulate_Beta_LASSO_std = Beta_LASSO_std,
    Simulate_Beta_SCAD_std = Beta_SCAD_std,
    Ave_Num_of_Zero_coeff_LASSO = c(avg_correct_LASSO,avg_incorrect_LASSO),
    Ave_Num_of_Zero_coeff_SCAD = c(avg_correct_SCAD,avg_incorrect_SCAD),
    MRME_LASSO = median(ME_LASSO/ME_part) * 100,
    MRME_SCAD = median(ME_SCAD/ME_part) * 100
  )
}


set.seed(87460945)
lasso_scad_cox_sim_75.out <- lasso_scad_cox_sim(N = 100, n = 75)
lasso_scad_cox_sim_100.out <- lasso_scad_cox_sim(N = 100, n = 100)

lasso_scad_cox_sim_100.out
```

```{r,echo=FALSE}
bic_simulation <- function(N, n) {
  Beta <- c(0.8, 0, 0, 1, 0, 0, 0.6, 0)  # True coefficients
  p <- length(Beta) 
  Beta_part_all = matrix(NA, N, p)
  ME_part = rep(NA, N)

  combinations_list <- lapply(1:p, function(r) {
    comb <- combinations(n = p, r = r)
    # Pad the combinations with NA to ensure they all have p columns
    padded_comb <- matrix(NA, nrow = nrow(comb), ncol = p)
    for (i in 1:nrow(comb)) {
      padded_comb[i, comb[i, ]] <- comb[i, ]
    }
    return(padded_comb)
  })
  all_combinations <- do.call(rbind, combinations_list)
  m <- nrow(all_combinations)

  t <- 1
  best_fit_AIC <- vector("list", N)
  best_fit_BIC <- vector("list", N)
  best_AICs <- numeric(N)
  best_BICs <- numeric(N)
  best_fit_AIC_indices <- vector("list", N)
  best_fit_BIC_indices <- vector("list", N)
  ME_AIC <- numeric(N)
  ME_BIC <- numeric(N)

  while (t <= N) {
    # Step 1: Generate correlation matrix
    corr <- matrix(NA, p, p)
    for (i in 1:p) {
      for (j in 1:p) {
        corr[i, j] <- (0.5) ^ (abs(i - j))
      }
    }

    # Step 2: Simulate data points
    x <- mvrnorm(n, rep(0, p), Sigma = corr)
    x <- scale(x) # Scale to make sure coefficients are in the same unit

    # Step 3: Generate survival time "y" using h(t)
    y <- rexp(n, rate = exp(x %*% Beta))

    # Step 4: Generate censoring time "cen"
    U = runif(n, min = 1, max = 3) # U is uniformly distributed on [1,3]
    cen = U
    
    # Step 5: Add status based on censoring time "cen" and actual survival time "y"
    status <- as.numeric(y <= cen) # 1 if death, 0 if censored

    # Step 6: Fit Cox PH model for each combination of covariates
    time <- pmin(y, cen) # Time until death or censoring
    
    fit_part = coxph(Surv(time, status) ~ x)
    Beta_part = as.numeric(coef(fit_part))
    Beta_part_all[t, ] = Beta_part
    
    AICs <- rep(Inf, m)
    BICs <- rep(Inf, m)
    fits <- vector("list", m)
    combination_indices <- vector("list", m)

    for (i in 1:m) {
      covariate_indices <- which(!is.na(all_combinations[i, ]))
      covariates <- x[, covariate_indices, drop = FALSE]
      fit <- tryCatch(coxph(Surv(time, status) ~ covariates), error = function(e) NULL)
      
      if (!is.null(fit)) {
        fits[[i]] <- fit
        AICs[i] <- AIC(fit)
        BICs[i] <- BIC(fit)
        combination_indices[[i]] <- covariate_indices
      }
    }
    best_AIC_idx <- which.min(AICs)
    best_BIC_idx <- which.min(BICs)

 if (is.finite(AICs[best_AIC_idx])) {
  best_fit_AIC[[t]] <- fits[[best_AIC_idx]]
  best_fit_AIC_indices[[t]] <- combination_indices[[best_AIC_idx]]
  names(best_fit_AIC_indices[[t]]) <- paste0("Beta_", combination_indices[[best_AIC_idx]])
  best_AICs[t] <- AICs[best_AIC_idx]
} else {
  best_fit_AIC[[t]] <- NULL
  best_fit_AIC_indices[[t]] <- NULL
  best_AICs[t] <- NA
}

if (is.finite(BICs[best_BIC_idx])) {
  best_fit_BIC[[t]] <- fits[[best_BIC_idx]]
  best_fit_BIC_indices[[t]] <- combination_indices[[best_BIC_idx]]
  names(best_fit_BIC_indices[[t]]) <- paste0("Beta_", combination_indices[[best_BIC_idx]])
  best_BICs[t] <- BICs[best_BIC_idx]
} else {
  best_fit_BIC[[t]] <- NULL
  best_fit_BIC_indices[[t]] <- NULL
  best_BICs[t] <- NA
}


    # Step 7: Compute Model Error for AIC and BIC models
    if (!is.null(best_fit_AIC_indices[[t]])) {
      selected_indices_AIC <- best_fit_AIC_indices[[t]]
      Beta_AIC <- numeric(p)
      Beta_AIC[selected_indices_AIC] <- coef(best_fit_AIC[[t]])
      ME_AIC[t] <- mean((exp(-x %*% Beta_AIC) - exp(-x %*% Beta))^2)
    } else {
      ME_AIC[t] <- NA
    }

    if (!is.null(best_fit_BIC_indices[[t]])) {
      selected_indices_BIC <- best_fit_BIC_indices[[t]]
      Beta_BIC <- numeric(p)
      Beta_BIC[selected_indices_BIC] <- coef(best_fit_BIC[[t]])
      ME_BIC[t] <- mean((exp(-x %*% Beta_BIC) - exp(-x %*% Beta))^2)
      ME_part[t] <- mean((exp(-x %*% Beta_part_all[t, ]) - exp(-x %*% Beta))^2)
    } else {
      ME_BIC[t] <- NA
    }

    t <- t + 1
  }

  correct_zero_AIC <- rep(0, N)
  correct_zero_BIC <- rep(0, N)
  incorrect_nonzero_AIC <- rep(0, N)
  incorrect_nonzero_BIC <- rep(0, N)

  for (i in 1:N) {
    true_zero_indices <- which(Beta == 0)
    true_nonzero_indices <- which(Beta != 0)
    
    # For AIC
    if (!is.null(best_fit_AIC_indices[[i]])) {
      selected_indices_AIC <- best_fit_AIC_indices[[i]]
      excluded_indices_AIC <- setdiff(1:length(Beta), selected_indices_AIC)
      correct_zero_AIC[i] <- sum(excluded_indices_AIC %in% true_zero_indices)
      incorrect_nonzero_AIC[i] <- sum(excluded_indices_AIC %in% true_nonzero_indices)
    }
    
    # For BIC
    if (!is.null(best_fit_BIC_indices[[i]])) {
      selected_indices_BIC <- best_fit_BIC_indices[[i]]
      excluded_indices_BIC <- setdiff(1:length(Beta), selected_indices_BIC)
      correct_zero_BIC[i] <- sum(excluded_indices_BIC %in% true_zero_indices)
      incorrect_nonzero_BIC[i] <- sum(excluded_indices_BIC %in% true_nonzero_indices)
    }
  }

  avg_correct_zero_AIC <- mean(correct_zero_AIC)
  avg_correct_zero_BIC <- mean(correct_zero_BIC)

  avg_incorrect_nonzero_AIC <- mean(incorrect_nonzero_AIC)
  avg_incorrect_nonzero_BIC <- mean(incorrect_nonzero_BIC)

  tb2_AIC_BIC <- data.frame(zero_coeff_AIC = avg_correct_zero_AIC, zero_coeff_BIC = avg_correct_zero_BIC, incorrect_nonzero_AIC = avg_incorrect_nonzero_AIC, incorrect_nonzero_BIC = avg_incorrect_nonzero_BIC)
  tb3_AIC_BIC <- data.frame(MRME_AIC = median(ME_AIC / ME_part, na.rm = TRUE) * 100, MRME_BIC = median(ME_BIC / ME_part, na.rm = TRUE) * 100)
  
  
  best_fit_AIC_indices_w_cor_coef <- lapply(best_fit_AIC_indices, function(x){sum(!(names(x) %in% c("Beta_1","Beta_4", "Beta_7"))) > 0})
  total_beta_1_AIC <- numeric(0)
  total_beta_4_AIC <- numeric(0)
  total_beta_7_AIC <- numeric(0)
  idx <- 0
  for (i in best_fit_AIC_indices_w_cor_coef) {
    idx <- idx + 1
    if(i==FALSE){
      total_beta_1_AIC <- c(total_beta_1_AIC , best_fit_AIC[[idx]]$coefficients[1])
      total_beta_4_AIC <- c(total_beta_4_AIC , best_fit_AIC[[idx]]$coefficients[2])
      total_beta_7_AIC <- c(total_beta_7_AIC , best_fit_AIC[[idx]]$coefficients[3])
    }
  }
  
  beta_1_AIC_mean <- mean(total_beta_1_AIC)
  beta_1_AIC_sd <- sd(total_beta_1_AIC)
  
  beta_4_AIC_mean <- mean(total_beta_4_AIC)
  beta_4_AIC_sd <- sd(total_beta_4_AIC)
  
  beta_7_AIC_mean <- mean(total_beta_7_AIC)
  beta_7_AIC_sd <- sd(total_beta_7_AIC)
  
  
  best_fit_BIC_indices_w_cor_coef <- lapply(best_fit_BIC_indices, function(x){sum(!(names(x) %in% c("Beta_1","Beta_4", "Beta_7"))) > 0})
  total_beta_1_BIC <- numeric(0)
  total_beta_4_BIC <- numeric(0)
  total_beta_7_BIC <- numeric(0)
  idx <- 0
  for (i in  best_fit_BIC_indices_w_cor_coef) {
    idx <- idx + 1
    if(i==FALSE){
      total_beta_1_BIC <- c(total_beta_1_BIC , best_fit_BIC[[idx]]$coefficients[1])
      total_beta_4_BIC <- c(total_beta_4_BIC , best_fit_BIC[[idx]]$coefficients[2])
      total_beta_7_BIC <- c(total_beta_7_BIC , best_fit_BIC[[idx]]$coefficients[3])
    }
  }
  
  beta_1_BIC_mean <- mean(total_beta_1_BIC,na.rm=TRUE)
  beta_1_BIC_sd <- sd(total_beta_1_BIC,na.rm=TRUE)
  
  beta_4_BIC_mean <- mean(total_beta_4_BIC,na.rm=TRUE)
  beta_4_BIC_sd <- sd(total_beta_4_BIC,na.rm=TRUE)
  
  beta_7_BIC_mean <- mean(total_beta_7_BIC,na.rm=TRUE)
  beta_7_BIC_sd <- sd(total_beta_7_BIC,na.rm=TRUE)
      
 

  beta_1_stats_AIC <- c(mean = beta_1_AIC_mean,
                        sd = beta_1_AIC_sd)
  beta_4_stats_AIC <- c(mean = beta_4_AIC_mean,
                        sd = beta_4_AIC_sd)
  beta_7_stats_AIC <- c(mean = beta_7_AIC_mean,
                        sd = beta_7_AIC_sd)
  
  beta_1_stats_BIC <- c(mean = beta_1_BIC_mean,
                        sd = beta_1_BIC_sd)
  beta_4_stats_BIC <- c(mean = beta_4_BIC_mean,
                        sd = beta_4_BIC_sd)
  beta_7_stats_BIC <- c(mean = beta_7_BIC_mean,
                        sd = beta_7_BIC_sd)
  
  beta_stats <- data.frame(beta_1_stats_AIC, beta_4_stats_AIC, beta_7_stats_AIC, beta_1_stats_BIC, beta_4_stats_BIC, beta_7_stats_BIC)

  list(tb2_AIC_BIC = tb2_AIC_BIC, tb3_AIC_BIC = tb3_AIC_BIC, beta_stats = beta_stats)
}

aic_bic_simulation_75.out <- bic_simulation(N = 100, n = 75)
aic_bic_simulation_100.out <- bic_simulation(N = 100, n = 100)
```

```{r,echo=FALSE}
library(knitr)

data <- data.frame(
  Column1 = c("**n=75**","SCAD","LASSO","AIC","BIC","**n=100**","SCAD","LASSO","AIC","BIC"),
  Column2 = c("",round(lasso_scad_cox_sim_75.out$MRME_SCAD,4) ,
              round(lasso_scad_cox_sim_75.out$MRME_LASSO,4),
              round(aic_bic_simulation_75.out$tb3_AIC_BIC$MRME_AIC,4),
              round(aic_bic_simulation_75.out$tb3_AIC_BIC$MRME_BIC,4),
              "",
              round(lasso_scad_cox_sim_100.out$MRME_SCAD,4),
              round(lasso_scad_cox_sim_100.out$MRME_LASSO,4),
              round(aic_bic_simulation_100.out$tb3_AIC_BIC$MRME_AIC,4),
              round(aic_bic_simulation_100.out$tb3_AIC_BIC$MRME_BIC,4)),
  Column3 = c("",
              round(lasso_scad_cox_sim_75.out$Ave_Num_of_Zero_coeff_SCAD[1],4),
              round(lasso_scad_cox_sim_75.out$Ave_Num_of_Zero_coeff_LASSO[1],4),
              round(aic_bic_simulation_75.out$tb2_AIC_BIC$zero_coeff_AIC,4),
              round(aic_bic_simulation_75.out$tb2_AIC_BIC$zero_coeff_BIC,4),
              "",
              round(lasso_scad_cox_sim_100.out$Ave_Num_of_Zero_coeff_SCAD[1],4),
              round(lasso_scad_cox_sim_100.out$Ave_Num_of_Zero_coeff_LASSO[1],4),
              round(aic_bic_simulation_100.out$tb2_AIC_BIC$zero_coeff_AIC,4),
              round(aic_bic_simulation_100.out$tb2_AIC_BIC$zero_coeff_BIC,4)),
  Column4 = c("",
              round(lasso_scad_cox_sim_75.out$Ave_Num_of_Zero_coeff_SCAD[2],4),
              round(lasso_scad_cox_sim_75.out$Ave_Num_of_Zero_coeff_LASSO[2],4),
              round(aic_bic_simulation_75.out$tb2_AIC_BIC$incorrect_nonzero_AIC,4),
              round(aic_bic_simulation_75.out$tb2_AIC_BIC$incorrect_nonzero_BIC,4),
              "",
              round(lasso_scad_cox_sim_100.out$Ave_Num_of_Zero_coeff_SCAD[2],4),
              round(lasso_scad_cox_sim_100.out$Ave_Num_of_Zero_coeff_LASSO[2],4),
              round(aic_bic_simulation_100.out$tb2_AIC_BIC$incorrect_nonzero_AIC,4),
              round(aic_bic_simulation_100.out$tb2_AIC_BIC$incorrect_nonzero_BIC,4))
)

kable(data, col.names = c("Method", "MRME(%)", "Aver. no. cor. 0 coeff.", "Aver. no. incor. 0 coeff."))
```

```{r,echo=FALSE}
data2 <- data.frame(
  Column1 = c("**n=75**","SCAD","LASSO","AIC","BIC","**n=100**","SCAD","LASSO","AIC","BIC"),
  Column2 = c("",round(lasso_scad_cox_sim_75.out$Simulate_Beta_SCAD_std[1],4) ,
              round(lasso_scad_cox_sim_75.out$Simulate_Beta_LASSO_std[1],4),
              round(aic_bic_simulation_75.out$beta_stats$beta_1_stats_AIC[2],4),
              round(aic_bic_simulation_75.out$beta_stats$beta_1_stats_BIC[2],4),
              "",
              round(lasso_scad_cox_sim_100.out$Simulate_Beta_SCAD_std[1],4),
              round(lasso_scad_cox_sim_100.out$Simulate_Beta_LASSO_std[1],4),
              round(aic_bic_simulation_100.out$beta_stat$beta_1_stats_AIC[2],4),
              round(aic_bic_simulation_100.out$beta_stats$beta_1_stats_BIC[2],4)),
  Column3 = c("",
              round(lasso_scad_cox_sim_75.out$Simulate_Beta_SCAD_std[4],4) ,
              round(lasso_scad_cox_sim_75.out$Simulate_Beta_LASSO_std[4],4),
              round(aic_bic_simulation_75.out$beta_stats$beta_4_stats_AIC[2],4),
              round(aic_bic_simulation_75.out$beta_stats$beta_4_stats_BIC[2],4),
              "",
              round(lasso_scad_cox_sim_100.out$Simulate_Beta_SCAD_std[4],4),
              round(lasso_scad_cox_sim_100.out$Simulate_Beta_LASSO_std[4],4),
              round(aic_bic_simulation_100.out$beta_stats$beta_4_stats_AIC[2],4),
              round(aic_bic_simulation_100.out$beta_stats$beta_4_stats_BIC[2],4)),
  Column4 = c("",round(lasso_scad_cox_sim_75.out$Simulate_Beta_SCAD_std[7],4) ,
              round(lasso_scad_cox_sim_75.out$Simulate_Beta_LASSO_std[7],4),
              round(aic_bic_simulation_75.out$beta_stats$beta_7_stats_AIC[2],4),
              round(aic_bic_simulation_75.out$beta_stats$beta_7_stats_BIC[2],4),
              "",
              round(lasso_scad_cox_sim_100.out$Simulate_Beta_SCAD_std[7],4),
              round(lasso_scad_cox_sim_100.out$Simulate_Beta_LASSO_std[7],4),
              round(aic_bic_simulation_100.out$beta_stats$beta_7_stats_AIC[2],4),
              round(aic_bic_simulation_100.out$beta_stats$beta_7_stats_BIC[2],4))
)

kable(data, col.names = c("Method", "Beta1 SD", "Beta4 SD", "Beta7 SD"))
```

# Application

# Data

```{r}
library(survival)
data(pbc)
kable(head(pbc))
```

Here is the description of the dataset from the R help file:

Primary biliary cholangitis is an autoimmune disease leading to destruction of the small bile ducts in the liver. Progression is slow but inexhortable, eventually leading to cirrhosis and liver decompensation. The condition has been recognised since at least 1851 and was named "primary biliary cirrhosis" in 1949. Because cirrhosis is a feature only of advanced disease, a change of its name to "primary biliary cholangitis" was proposed by patient advocacy groups in 2014.

This data is from the Mayo Clinic trial in PBC conducted between 1974 and 1984. A total of 424 PBC patients, referred to Mayo Clinic during that ten-year interval, met eligibility criteria for the randomized placebo controlled trial of the drug D-penicillamine. The first 312 cases in the data set participated in the randomized trial and contain largely complete data. The additional 112 cases did not participate in the clinical trial, but consented to have basic measurements recorded and to be followed for survival. Six of those cases were lost to follow-up shortly after diagnosis, so the data here are on an additional 106 cases as well as the 312 randomized participants.

The variables are as follows:

| Variable | Description |
|-----------------|-------------------------------------------------------|
| age | in years |
| albumin | serum albumin (g/dl) |
| alk.phos | alkaline phosphatase (U/liter) |
| ascites | presence of ascites |
| ast | aspartate aminotransferase, once called SGOT (U/ml) |
| bili | serum bilirubin (mg/dl) |
| chol | serum cholesterol (mg/dl) |
| copper | urine copper (ug/day) |
| edema | 0 no edema, 0.5 untreated or successfully treated, 1 edema despite diuretic therapy |
| hepato | presence of hepatomegaly or enlarged liver |
| id | case number |
| platelet | platelet count |
| protime | standardized blood clotting time |
| sex | m/f |
| spiders | blood vessel malformations in the skin |
| stage | histologic stage of disease (needs biopsy) |
| status | status at endpoint, 0/1/2 for censored, transplant, dead |
| time | number of days between registration and the earlier of death, transplantation, or study analysis in July, 1986 |
| trt | 1/2/NA for D-penicillamine, placebo, not randomized |
| trig | triglycerides (mg/dl) |

```{r}
# Install and load the necessary package
if (!require("rgl")) {
  install.packages("rgl")
}
library(rgl)

# Define the range of theta
theta <- seq(-2, 2, length.out = 1000)  # Adjust the range as needed

# Calculate x, y, z based on the parametric equations
x <- 4 * theta
y <- -6 * theta^2
z <- 4 * theta^3

# Plot the 3D curve
plot3d(x, y, z, type = "l", col = "blue", lwd = 2,
       xlab = expression(x == 4 * theta),
       ylab = expression(y == -6 * theta^2),
       zlab = expression(z == 4 * theta^3),
       main = "Parameter Space Plot")

# Add grid and axes labels
grid3d("x")
grid3d("y")
grid3d("z")

```

# References

::: {#refs}
:::
