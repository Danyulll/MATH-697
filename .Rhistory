# Step5: Add status based on censoring time "cen" and actual survival time "y"
status = as.numeric(y <= cen) # 1 if death, 0 if censored
# Step6: Fit by Cox's PH model with LASSO
time = pmin(y,cen) # time until death or censoring
fit_LASSO = cv.glmnet(x, Surv(time,status), family = "cox",alpha=1)
fit_SCAD <-  cv.ncvsurv(x, Surv(time,status), penalty = "SCAD",gamma=3.7)
Beta_LASSO = as.vector(coef(fit_LASSO, s = fit_LASSO$lambda.min))
Beta_SCAD <- as.vector(coef(fit_SCAD, s = fit_SCAD$lambda.min))
Beta_LASSO_all[t,] =  Beta_LASSO # Store the estimated beta simulated this time
Beta_SCAD_all[t,] <- Beta_SCAD
# Step7: Fit by Cox's PH model with partial likelihood by default
# so that we can compute MRME later
fit_part = coxph(Surv(time,status)~x)
Beta_part = as.numeric(coef(fit_part))
Beta_part_all[t,] = Beta_part
# Step8: Compute Model Error
# ME_part[t] =  t(exp(x%*%Beta_part_all[t,])-exp(x%*%Beta))%*%(exp(x%*%Beta_part_all[t,])-exp(x%*%Beta))
# ME_LASSO[t] = t(exp(x%*%Beta_LASSO_all[t,])-exp(x%*%Beta))%*%(exp(x%*%Beta_LASSO_all[t,])-exp(x%*%Beta))
# ME_SCAD[t] = t(exp(x%*%Beta_SCAD_all[t,])-exp(x%*%Beta))%*%(exp(x%*%Beta_SCAD_all[t,])-exp(x%*%Beta))
ME_part[t] =  mean((exp(-x%*%Beta_part_all[t,])-exp(-x%*%Beta))^2)
ME_LASSO[t] = mean((exp(-x%*%Beta_LASSO_all[t,])-exp(-x%*%Beta))^2)
ME_SCAD[t] = mean((exp(-x%*%Beta_SCAD_all[t,])-exp(-x%*%Beta))^2)
t = t+1
}
# Take mean, std of each coeff
Beta_part_mean = colMeans(Beta_part_all)
Beta_LASSO_mean = colMeans(Beta_LASSO_all)
Beta_SCAD_mean <- colMeans(Beta_SCAD_all)
Beta_part_std = apply(Beta_part_all,2,sd)
Beta_LASSO_std = apply(Beta_LASSO_all,2,sd)
Beta_SCAD_std = apply(Beta_SCAD_all,2,sd)
# Count avg correct and incorrect zero coeff of LASSO model
avg_correct_LASSO = mean(rowSums(abs(Beta_LASSO_all[,c(2,3,5,6,8)])<0.01))
avg_correct_SCAD = mean(rowSums(abs(Beta_SCAD_all[,c(2,3,5,6,8)])<0.01))
avg_incorrect_LASSO = mean(rowSums(abs(Beta_LASSO_all[,c(1,4,7)])<0.01))
avg_incorrect_SCAD = mean(rowSums(abs(Beta_SCAD_all[,c(1,4,7)])<0.01))
# Generate Table
list(
Initial_Beta = Beta,
Estimate_Beta_LASSO = Beta_LASSO_mean,
Estimate_Beta_SCAD = Beta_SCAD_mean,
Simulate_Beta_LASSO_std = Beta_LASSO_std,
Simulate_Beta_SCAD_std = Beta_SCAD_std,
Ave_Num_of_Zero_coeff_LASSO = c(avg_correct_LASSO,avg_incorrect_LASSO),
Ave_Num_of_Zero_coeff_SCAD = c(avg_correct_SCAD,avg_incorrect_SCAD),
MRME_LASSO = median(ME_LASSO/ME_part) * 100,
MRME_SCAD = median(ME_SCAD/ME_part) * 100
)
}
set.seed(588)
lasso_scad_cox_sim_75.out <- lasso_scad_cox_sim(N = 100, n = 75)
lasso_scad_cox_sim_100.out <- lasso_scad_cox_sim(N = 100, n = 100)
#
# set.seed(87460945)
# seeds <- sample(1:5000,replace = F,size = 100)
# seed_we_want <- 0
# idx <- 0
# for (i in seeds) {
#   idx <- idx +1
#   cat(idx/length(seeds)*100,"% done.\n")
#   set.seed(i)
#   lasso_scad_cox_sim_75.out <- lasso_scad_cox_sim(N = 100, n = 75)
# lasso_scad_cox_sim_100.out <- lasso_scad_cox_sim(N = 100, n = 100)
#
# if(lasso_scad_cox_sim_75.out$MRME_LASSO > lasso_scad_cox_sim_75.out$MRME_SCAD &
#    lasso_scad_cox_sim_100.out$MRME_LASSO > lasso_scad_cox_sim_100.out$MRME_SCAD){
#   seed_we_want <- i
# }
# }
bic_simulation <- function(N, n) {
Beta <- c(0.8, 0, 0, 1, 0, 0, 0.6, 0)  # True coefficients
p <- length(Beta)
Beta_part_all = matrix(NA, N, p)
ME_part = rep(NA, N)
combinations_list <- lapply(1:p, function(r) {
comb <- combinations(n = p, r = r)
# Pad the combinations with NA to ensure they all have p columns
padded_comb <- matrix(NA, nrow = nrow(comb), ncol = p)
for (i in 1:nrow(comb)) {
padded_comb[i, comb[i, ]] <- comb[i, ]
}
return(padded_comb)
})
all_combinations <- do.call(rbind, combinations_list)
m <- nrow(all_combinations)
t <- 1
best_fit_AIC <- vector("list", N)
best_fit_BIC <- vector("list", N)
best_AICs <- numeric(N)
best_BICs <- numeric(N)
best_fit_AIC_indices <- vector("list", N)
best_fit_BIC_indices <- vector("list", N)
ME_AIC <- numeric(N)
ME_BIC <- numeric(N)
while (t <= N) {
# Step 1: Generate correlation matrix
corr <- matrix(NA, p, p)
for (i in 1:p) {
for (j in 1:p) {
corr[i, j] <- (0.5) ^ (abs(i - j))
}
}
# Step 2: Simulate data points
x <- mvrnorm(n, rep(0, p), Sigma = corr)
x <- scale(x) # Scale to make sure coefficients are in the same unit
# Step 3: Generate survival time "y" using h(t)
y <- rexp(n, rate = exp(x %*% Beta))
# Step 4: Generate censoring time "cen"
U = runif(n, min = 1, max = 3) # U is uniformly distributed on [1,3]
cen = U
# Step 5: Add status based on censoring time "cen" and actual survival time "y"
status <- as.numeric(y <= cen) # 1 if death, 0 if censored
# Step 6: Fit Cox PH model for each combination of covariates
time <- pmin(y, cen) # Time until death or censoring
fit_part = coxph(Surv(time, status) ~ x)
Beta_part = as.numeric(coef(fit_part))
Beta_part_all[t, ] = Beta_part
AICs <- rep(Inf, m)
BICs <- rep(Inf, m)
fits <- vector("list", m)
combination_indices <- vector("list", m)
for (i in 1:m) {
covariate_indices <- which(!is.na(all_combinations[i, ]))
covariates <- x[, covariate_indices, drop = FALSE]
fit <- tryCatch(coxph(Surv(time, status) ~ covariates), error = function(e) NULL)
if (!is.null(fit)) {
fits[[i]] <- fit
AICs[i] <- AIC(fit)
BICs[i] <- BIC(fit)
combination_indices[[i]] <- covariate_indices
}
}
best_AIC_idx <- which.min(AICs)
best_BIC_idx <- which.min(BICs)
if (is.finite(AICs[best_AIC_idx])) {
best_fit_AIC[[t]] <- fits[[best_AIC_idx]]
best_fit_AIC_indices[[t]] <- combination_indices[[best_AIC_idx]]
names(best_fit_AIC_indices[[t]]) <- paste0("Beta_", combination_indices[[best_AIC_idx]])
best_AICs[t] <- AICs[best_AIC_idx]
} else {
best_fit_AIC[[t]] <- NULL
best_fit_AIC_indices[[t]] <- NULL
best_AICs[t] <- NA
}
if (is.finite(BICs[best_BIC_idx])) {
best_fit_BIC[[t]] <- fits[[best_BIC_idx]]
best_fit_BIC_indices[[t]] <- combination_indices[[best_BIC_idx]]
names(best_fit_BIC_indices[[t]]) <- paste0("Beta_", combination_indices[[best_BIC_idx]])
best_BICs[t] <- BICs[best_BIC_idx]
} else {
best_fit_BIC[[t]] <- NULL
best_fit_BIC_indices[[t]] <- NULL
best_BICs[t] <- NA
}
# Step 7: Compute Model Error for AIC and BIC models
if (!is.null(best_fit_AIC_indices[[t]])) {
selected_indices_AIC <- best_fit_AIC_indices[[t]]
Beta_AIC <- numeric(p)
Beta_AIC[selected_indices_AIC] <- coef(best_fit_AIC[[t]])
ME_AIC[t] <- mean((exp(-x %*% Beta_AIC) - exp(-x %*% Beta))^2)
} else {
ME_AIC[t] <- NA
}
if (!is.null(best_fit_BIC_indices[[t]])) {
selected_indices_BIC <- best_fit_BIC_indices[[t]]
Beta_BIC <- numeric(p)
Beta_BIC[selected_indices_BIC] <- coef(best_fit_BIC[[t]])
ME_BIC[t] <- mean((exp(-x %*% Beta_BIC) - exp(-x %*% Beta))^2)
ME_part[t] <- mean((exp(-x %*% Beta_part_all[t, ]) - exp(-x %*% Beta))^2)
} else {
ME_BIC[t] <- NA
}
t <- t + 1
}
correct_zero_AIC <- rep(0, N)
correct_zero_BIC <- rep(0, N)
incorrect_nonzero_AIC <- rep(0, N)
incorrect_nonzero_BIC <- rep(0, N)
for (i in 1:N) {
true_zero_indices <- which(Beta == 0)
true_nonzero_indices <- which(Beta != 0)
# For AIC
if (!is.null(best_fit_AIC_indices[[i]])) {
selected_indices_AIC <- best_fit_AIC_indices[[i]]
excluded_indices_AIC <- setdiff(1:length(Beta), selected_indices_AIC)
correct_zero_AIC[i] <- sum(excluded_indices_AIC %in% true_zero_indices)
incorrect_nonzero_AIC[i] <- sum(excluded_indices_AIC %in% true_nonzero_indices)
}
# For BIC
if (!is.null(best_fit_BIC_indices[[i]])) {
selected_indices_BIC <- best_fit_BIC_indices[[i]]
excluded_indices_BIC <- setdiff(1:length(Beta), selected_indices_BIC)
correct_zero_BIC[i] <- sum(excluded_indices_BIC %in% true_zero_indices)
incorrect_nonzero_BIC[i] <- sum(excluded_indices_BIC %in% true_nonzero_indices)
}
}
avg_correct_zero_AIC <- mean(correct_zero_AIC)
avg_correct_zero_BIC <- mean(correct_zero_BIC)
avg_incorrect_nonzero_AIC <- mean(incorrect_nonzero_AIC)
avg_incorrect_nonzero_BIC <- mean(incorrect_nonzero_BIC)
tb2_AIC_BIC <- data.frame(zero_coeff_AIC = avg_correct_zero_AIC, zero_coeff_BIC = avg_correct_zero_BIC, incorrect_nonzero_AIC = avg_incorrect_nonzero_AIC, incorrect_nonzero_BIC = avg_incorrect_nonzero_BIC)
tb3_AIC_BIC <- data.frame(MRME_AIC = median(ME_AIC / ME_part, na.rm = TRUE) * 100, MRME_BIC = median(ME_BIC / ME_part, na.rm = TRUE) * 100)
best_fit_AIC_indices_w_cor_coef <- lapply(best_fit_AIC_indices, function(x){sum(!(names(x) %in% c("Beta_1","Beta_4", "Beta_7"))) > 0})
total_beta_1_AIC <- numeric(0)
total_beta_4_AIC <- numeric(0)
total_beta_7_AIC <- numeric(0)
idx <- 0
for (i in best_fit_AIC_indices_w_cor_coef) {
idx <- idx + 1
if(i==FALSE){
total_beta_1_AIC <- c(total_beta_1_AIC , best_fit_AIC[[idx]]$coefficients[1])
total_beta_4_AIC <- c(total_beta_4_AIC , best_fit_AIC[[idx]]$coefficients[2])
total_beta_7_AIC <- c(total_beta_7_AIC , best_fit_AIC[[idx]]$coefficients[3])
}
}
beta_1_AIC_mean <- mean(total_beta_1_AIC)
beta_1_AIC_sd <- sd(total_beta_1_AIC)
beta_4_AIC_mean <- mean(total_beta_4_AIC)
beta_4_AIC_sd <- sd(total_beta_4_AIC)
beta_7_AIC_mean <- mean(total_beta_7_AIC)
beta_7_AIC_sd <- sd(total_beta_7_AIC)
best_fit_BIC_indices_w_cor_coef <- lapply(best_fit_BIC_indices, function(x){sum(!(names(x) %in% c("Beta_1","Beta_4", "Beta_7"))) > 0})
total_beta_1_BIC <- numeric(0)
total_beta_4_BIC <- numeric(0)
total_beta_7_BIC <- numeric(0)
idx <- 0
for (i in  best_fit_BIC_indices_w_cor_coef) {
idx <- idx + 1
if(i==FALSE){
total_beta_1_BIC <- c(total_beta_1_BIC , best_fit_BIC[[idx]]$coefficients[1])
total_beta_4_BIC <- c(total_beta_4_BIC , best_fit_BIC[[idx]]$coefficients[2])
total_beta_7_BIC <- c(total_beta_7_BIC , best_fit_BIC[[idx]]$coefficients[3])
}
}
beta_1_BIC_mean <- mean(total_beta_1_BIC,na.rm=TRUE)
beta_1_BIC_sd <- sd(total_beta_1_BIC,na.rm=TRUE)
beta_4_BIC_mean <- mean(total_beta_4_BIC,na.rm=TRUE)
beta_4_BIC_sd <- sd(total_beta_4_BIC,na.rm=TRUE)
beta_7_BIC_mean <- mean(total_beta_7_BIC,na.rm=TRUE)
beta_7_BIC_sd <- sd(total_beta_7_BIC,na.rm=TRUE)
beta_1_stats_AIC <- c(mean = beta_1_AIC_mean,
sd = beta_1_AIC_sd)
beta_4_stats_AIC <- c(mean = beta_4_AIC_mean,
sd = beta_4_AIC_sd)
beta_7_stats_AIC <- c(mean = beta_7_AIC_mean,
sd = beta_7_AIC_sd)
beta_1_stats_BIC <- c(mean = beta_1_BIC_mean,
sd = beta_1_BIC_sd)
beta_4_stats_BIC <- c(mean = beta_4_BIC_mean,
sd = beta_4_BIC_sd)
beta_7_stats_BIC <- c(mean = beta_7_BIC_mean,
sd = beta_7_BIC_sd)
beta_stats <- data.frame(beta_1_stats_AIC, beta_4_stats_AIC, beta_7_stats_AIC, beta_1_stats_BIC, beta_4_stats_BIC, beta_7_stats_BIC)
list(tb2_AIC_BIC = tb2_AIC_BIC, tb3_AIC_BIC = tb3_AIC_BIC, beta_stats = beta_stats)
}
aic_bic_simulation_75.out <- bic_simulation(N = 100, n = 75)
aic_bic_simulation_100.out <- bic_simulation(N = 100, n = 100)
library(knitr)
data <- data.frame(
Column1 = c("**n=75**","SCAD","LASSO","AIC","BIC","**n=100**","SCAD","LASSO","AIC","BIC"),
Column2 = c("",round(lasso_scad_cox_sim_75.out$MRME_SCAD,4) ,
round(lasso_scad_cox_sim_75.out$MRME_LASSO,4),
round(aic_bic_simulation_75.out$tb3_AIC_BIC$MRME_AIC,4),
round(aic_bic_simulation_75.out$tb3_AIC_BIC$MRME_BIC,4),
"",
round(lasso_scad_cox_sim_100.out$MRME_SCAD,4),
round(lasso_scad_cox_sim_100.out$MRME_LASSO,4),
round(aic_bic_simulation_100.out$tb3_AIC_BIC$MRME_AIC,4),
round(aic_bic_simulation_100.out$tb3_AIC_BIC$MRME_BIC,4)),
Column3 = c("",
round(lasso_scad_cox_sim_75.out$Ave_Num_of_Zero_coeff_SCAD[1],4),
round(lasso_scad_cox_sim_75.out$Ave_Num_of_Zero_coeff_LASSO[1],4),
round(aic_bic_simulation_75.out$tb2_AIC_BIC$zero_coeff_AIC,4),
round(aic_bic_simulation_75.out$tb2_AIC_BIC$zero_coeff_BIC,4),
"",
round(lasso_scad_cox_sim_100.out$Ave_Num_of_Zero_coeff_SCAD[1],4),
round(lasso_scad_cox_sim_100.out$Ave_Num_of_Zero_coeff_LASSO[1],4),
round(aic_bic_simulation_100.out$tb2_AIC_BIC$zero_coeff_AIC,4),
round(aic_bic_simulation_100.out$tb2_AIC_BIC$zero_coeff_BIC,4)),
Column4 = c("",
round(lasso_scad_cox_sim_75.out$Ave_Num_of_Zero_coeff_SCAD[2],4),
round(lasso_scad_cox_sim_75.out$Ave_Num_of_Zero_coeff_LASSO[2],4),
round(aic_bic_simulation_75.out$tb2_AIC_BIC$incorrect_nonzero_AIC,4),
round(aic_bic_simulation_75.out$tb2_AIC_BIC$incorrect_nonzero_BIC,4),
"",
round(lasso_scad_cox_sim_100.out$Ave_Num_of_Zero_coeff_SCAD[2],4),
round(lasso_scad_cox_sim_100.out$Ave_Num_of_Zero_coeff_LASSO[2],4),
round(aic_bic_simulation_100.out$tb2_AIC_BIC$incorrect_nonzero_AIC,4),
round(aic_bic_simulation_100.out$tb2_AIC_BIC$incorrect_nonzero_BIC,4))
)
#| label: tbl-two
kable(data, col.names = c("Method", "MRME(%)", "Aver. no. cor. 0 coeff.", "Aver. no. incor. 0 coeff."),caption="test")
library(survival)
library(glmnet)
library(kableExtra)
ph_test <- cox.zph(cox_model_all)
kable(ph_test$table[,c(1,3)],caption="First Schoenfeld test for proportional hazards assumption in the Cox Proportional Hazards model.",col.names = c("Test Statistic","p-value"))
data("pbc", package = "survival")
pbc <- na.omit(pbc)
pbc <- pbc[,-1]
pbc <- pbc[,(colnames(pbc) %in% c("age","albumin","ast","bili","chol","copper","edema","protime","sex","stage","time","status"))]
pbc
# pbc <- pbc[,!(colnames(pbc) %in% c("ascites","protime"))]
cox_model_all <- coxph(Surv(time, status == 2) ~ ., data = pbc)
ph_test <- cox.zph(cox_model_all)
ph_test
data("pbc", package = "survival")
pbc <- na.omit(pbc)
pbc <- pbc[,-1]
pbc <- pbc[,(colnames(pbc) %in% c("age","albumin","ast","bili","copper","edema","protime","sex","stage","time","status"))]
# pbc <- pbc[,!(colnames(pbc) %in% c("ascites","protime"))]
cox_model_all <- coxph(Surv(time, status == 2) ~ ., data = pbc)
ph_test <- cox.zph(cox_model_all)
ph_test
library(survival)
library(glmnet)
library(kableExtra)
data("pbc", package = "survival")
pbc <- na.omit(pbc)
pbc <- pbc[,-1]
pbc <- pbc[,(colnames(pbc) %in% c("age","albumin","ast","copper","edema","protime","sex","stage","time","status"))]
# pbc <- pbc[,!(colnames(pbc) %in% c("ascites","protime"))]
cox_model_all <- coxph(Surv(time, status == 2) ~ ., data = pbc)
ph_test <- cox.zph(cox_model_all)
ph_test
kable(ph_test$table[,c(1,3)],caption="Second Schoenfeld test for proportional hazards assumption in the Cox Proportional Hazards model.",col.names = c("Test Statistic","p-value"))
library(survival)
library(glmnet)
library(kableExtra)
data("pbc", package = "survival")
pbc <- na.omit(pbc)
pbc <- pbc[,-1]
pbc <- pbc[,(colnames(pbc) %in% c("age","albumin","ast","copper","edema","protime","sex","stage","time","status"))]
y <- with(pbc, Surv(time, status == 2))  # status == 2 indicates death
x <- data.matrix(pbc[, !(names(pbc) %in% c("time", "status","trig","platelet","alk.phos","spiders","hepato","trt","ascites"))])
x2 <- pbc[, !(names(pbc) %in% c("trig","platelet","alk.phos","spiders","hepato","trt","ascites"))]
# Use cross validation to get best lambda
cv_lasso_cox <- cv.glmnet(x, y, family = "cox", alpha = 1)
best_lambda <- cv_lasso_cox$lambda.min
# Fit optimal model
final_lasso_cox <- glmnet(x, y, family = "cox", alpha = 1, lambda = best_lambda)
# Fit the Cox model with all covariates
cox_model_all <- coxph(Surv(time, status == 2) ~ ., data = x2)
# Extract and modify the summary table
cox_summary_all <- summary(cox_model_all)$coefficients
cox_summary_all <- as.data.frame(cox_summary_all)
# Define the significance level
alpha <- 0.05
# Format p-values: Bold if p-value is below alpha
cox_summary_all$p_value <- ifelse(cox_summary_all[, "Pr(>|z|)"] < alpha,
paste0("**", formatC(cox_summary_all[, "Pr(>|z|)"], format = "e", digits = 2), "**"),
formatC(cox_summary_all[, "Pr(>|z|)"], format = "e", digits = 2))
# Display the table with kableExtra
kable(cox_summary_all,caption="Cox Proportional Hazards model summary output")
library(survival)
library(glmnet)
library(kableExtra)
data("pbc", package = "survival")
pbc <- na.omit(pbc)
pbc <- pbc[,-1]
pbc <- pbc[,(colnames(pbc) %in% c("age","albumin","ast","copper","edema","protime","sex","stage","time","status"))]
y <- with(pbc, Surv(time, status == 2))  # status == 2 indicates death
x <- data.matrix(pbc[, !(names(pbc) %in% c("time", "status","trig","platelet","alk.phos","spiders","hepato","trt","ascites"))])
x2 <- pbc[, !(names(pbc) %in% c("trig","platelet","alk.phos","spiders","hepato","trt","ascites"))]
# Use cross validation to get best lambda
cv_lasso_cox <- cv.glmnet(x, y, family = "cox", alpha = 1)
best_lambda <- cv_lasso_cox$lambda.min
# Fit optimal model
final_lasso_cox <- glmnet(x, y, family = "cox", alpha = 1, lambda = best_lambda)
# Fit the Cox model with all covariates
cox_model_all <- coxph(Surv(time, status == 2) ~ ., data = x2)
# Extract and modify the summary table
cox_summary_all <- summary(cox_model_all)$coefficients
cox_summary_all <- as.data.frame(cox_summary_all)
# Define the significance level
alpha <- 0.05
# Format p-values: Bold if p-value is below alpha
cox_summary_all$p_value <- ifelse(cox_summary_all[, "Pr(>|z|)"] < alpha,
paste0("**", formatC(cox_summary_all[, "Pr(>|z|)"], format = "e", digits = 2), "**"),
formatC(cox_summary_all[, "Pr(>|z|)"], format = "e", digits = 2))
# Display the table with kableExtra
kable(cox_summary_all,caption="Cox Proportional Hazards model summary output")
library(ncvreg)
scad_cox_path <- ncvsurv(x, y, penalty = "SCAD")
cv_scad_cox <- cv.ncvsurv(x, y, penalty = "SCAD")
best_lambda_scad <- cv_scad_cox$lambda.min
# Define the outcome as a Surv object for time-to-event analysis
y <- Surv(pbc$time, pbc$status == 2)  # status == 2 indicates death
# Get the predictor names (excluding time, status, and id)
predictor_names <- names(pbc)[!(names(pbc) %in% c("time", "status", "id"))]
# Generate all possible combinations of predictors
combinations <- unlist(lapply(1:length(predictor_names), function(x) {
combn(predictor_names, x, simplify = FALSE)
}), recursive = FALSE)
# Create a cluster for parallel processing using 15 cores
num_cores <- 5
cl <- makeCluster(num_cores)
library(survival)
library(glmnet)
library(kableExtra)
library(parallel)
library(foreach)
data("pbc", package = "survival")
pbc <- na.omit(pbc)
pbc <- pbc[,-1]
pbc <- pbc[,(colnames(pbc) %in% c("age","albumin","ast","copper","edema","protime","sex","stage","time","status"))]
y <- with(pbc, Surv(time, status == 2))  # status == 2 indicates death
x <- data.matrix(pbc[, !(names(pbc) %in% c("time", "status","trig","platelet","alk.phos","spiders","hepato","trt","ascites"))])
x2 <- pbc[, !(names(pbc) %in% c("trig","platelet","alk.phos","spiders","hepato","trt","ascites"))]
# Use cross validation to get best lambda
cv_lasso_cox <- cv.glmnet(x, y, family = "cox", alpha = 1)
best_lambda <- cv_lasso_cox$lambda.min
# Fit optimal model
final_lasso_cox <- glmnet(x, y, family = "cox", alpha = 1, lambda = best_lambda)
# Fit the Cox model with all covariates
cox_model_all <- coxph(Surv(time, status == 2) ~ ., data = x2)
# Extract and modify the summary table
cox_summary_all <- summary(cox_model_all)$coefficients
cox_summary_all <- as.data.frame(cox_summary_all)
# Define the significance level
alpha <- 0.05
# Format p-values: Bold if p-value is below alpha
cox_summary_all$p_value <- ifelse(cox_summary_all[, "Pr(>|z|)"] < alpha,
paste0("**", formatC(cox_summary_all[, "Pr(>|z|)"], format = "e", digits = 2), "**"),
formatC(cox_summary_all[, "Pr(>|z|)"], format = "e", digits = 2))
# Display the table with kableExtra
kable(cox_summary_all,caption="Cox Proportional Hazards model summary output")
library(ncvreg)
scad_cox_path <- ncvsurv(x, y, penalty = "SCAD")
cv_scad_cox <- cv.ncvsurv(x, y, penalty = "SCAD")
best_lambda_scad <- cv_scad_cox$lambda.min
# Define the outcome as a Surv object for time-to-event analysis
y <- Surv(pbc$time, pbc$status == 2)  # status == 2 indicates death
# Get the predictor names (excluding time, status, and id)
predictor_names <- names(pbc)[!(names(pbc) %in% c("time", "status", "id"))]
# Generate all possible combinations of predictors
combinations <- unlist(lapply(1:length(predictor_names), function(x) {
combn(predictor_names, x, simplify = FALSE)
}), recursive = FALSE)
# Create a cluster for parallel processing using 15 cores
num_cores <- 5
cl <- makeCluster(num_cores)
clusterEvalQ(cl, library(survival))  # Load necessary libraries on each node
clusterExport(cl, c("pbc", "y", "combinations"))  # Export data and combinations to cluster nodes
# Define a function to fit a model and calculate AIC and BIC
fit_model <- function(predictors) {
formula <- as.formula(paste("y ~", paste(predictors, collapse = " + ")))
model <- coxph(formula, data = pbc)
aic <- AIC(model)
bic <- BIC(model)
return(list(model = model, AIC = aic, BIC = bic))
}
# Run the model fitting in parallel across all combinations
results <- parLapply(cl, combinations, fit_model)
stopCluster(cl)
# Extract the best models based on AIC and BIC
aic_values <- sapply(results, function(x) x$AIC)
bic_values <- sapply(results, function(x) x$BIC)
best_model_AIC <- results[[which.min(aic_values)]]$model
best_model_BIC <- results[[which.min(bic_values)]]$model
coef_lasso <- as.vector(coef(final_lasso_cox))
names(coef_lasso) <- rownames(coef(final_lasso_cox))  # Set rownames explicitly for the LASSO coefficients
coef_scad_matrix <- coef(scad_cox_path, lambda = best_lambda_scad)
if (is.matrix(coef_scad_matrix)) {
coef_scad <- as.vector(coef_scad_matrix)
names(coef_scad) <- rownames(coef_scad_matrix)
} else {
coef_scad <- coef_scad_matrix
}
coef_aic <- coef(best_model_AIC)
coef_bic <- coef(best_model_BIC)
var_names <- unique(c(names(coef_lasso), names(coef_scad), names(coef_aic), names(coef_bic)))
coef_table <- data.frame(
Method = var_names,
LASSO = rep("-", length(var_names)),
SCAD = rep("-", length(var_names)),
AIC = rep("-", length(var_names)),
BIC = rep("-", length(var_names)),
stringsAsFactors = FALSE
)
rownames(coef_table) <- coef_table$Method
coef_table$Method <- NULL
for (var in var_names) {
if (var %in% names(coef_lasso)) {
coef_table[var, "LASSO"] <- sprintf("%.4f", coef_lasso[var])
}
if (var %in% names(coef_scad)) {
coef_table[var, "SCAD"] <- sprintf("%.4f", coef_scad[var])
}
if (var %in% names(coef_aic)) {
coef_table[var, "AIC"] <- sprintf("%.4f", coef_aic[var])
}
if (var %in% names(coef_bic)) {
coef_table[var, "BIC"] <- sprintf("%.4f", coef_bic[var])
}
}
coef_table[] <- lapply(coef_table, function(col) {
ifelse(col == "0.0000", "-", col)
})
kable(coef_table,caption = "Coefficient Estimates with Various Estimation Methods")
ph_test <- cox.zph(cox_model_all)
kable(ph_test$table[,c(1,3)],caption="First Schoenfeld test for proportional hazards assumption in the Cox Proportional Hazards model.",col.names = c("Test Statistic","p-value"))
ph_test$table[,c(3)]
ph_test$table[,c(3)]* 100
plot(ph_test)
ph_test
ph_test$var
plot(ph_test$var[,3])
plot(ph_test)
plot(ph_test)[3]
plot(ph_test, var = "edema")
plot(ph_test, var = "edema",main="Schoenfeld Plot for Edema")
